use crate::{
    group::{proposal_filter::ProposalBundle, ProposalType, Sender},
    key_package::KeyPackageValidationError,
    tree_kem::{
        leaf_node::LeafNodeError, leaf_node_validator::LeafNodeValidationError, node::LeafIndex,
        RatchetTreeError,
    },
    ProtocolVersion,
};
use std::marker::PhantomData;
use thiserror::Error;

pub trait ProposalFilter {
    type Error: std::error::Error + Send + Sync + 'static;

    /// This is called to validate a received commit. It should report any error making the commit
    /// invalid.
    fn validate(&self, proposals: &ProposalBundle) -> Result<(), Self::Error>;

    /// This is called when preparing a commit. By-reference proposals causing the commit to be
    /// invalid should be filtered out. If a by-value proposal causes the commit to be invalid,
    /// an error should be returned.
    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error>;

    fn and<T>(self, other: T) -> And<Self, T>
    where
        Self: Sized,
        T: ProposalFilter<Error = Self::Error>,
    {
        And(self, other)
    }

    fn map_err<F, E>(self, f: F) -> MapErr<Self, F>
    where
        Self: Sized,
        F: Fn(Self::Error) -> E,
    {
        MapErr {
            filter: self,
            map: f,
        }
    }

    fn boxed(self) -> BoxedProposalFilter<Self::Error>
    where
        Self: Send + Sync + Sized + 'static,
    {
        Box::new(self)
    }
}

pub type BoxedProposalFilter<E> = Box<dyn ProposalFilter<Error = E> + Send + Sync>;

impl<T: ProposalFilter + ?Sized> ProposalFilter for Box<T> {
    type Error = T::Error;

    fn validate(&self, proposals: &ProposalBundle) -> Result<(), Self::Error> {
        (**self).validate(proposals)
    }

    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error> {
        (**self).filter(proposals)
    }
}

#[derive(Clone, Debug)]
pub struct And<A, B>(A, B);

impl<A, B> ProposalFilter for And<A, B>
where
    A: ProposalFilter,
    B: ProposalFilter<Error = A::Error>,
{
    type Error = A::Error;

    fn validate(&self, proposals: &ProposalBundle) -> Result<(), Self::Error> {
        self.0.validate(proposals)?;
        self.1.validate(proposals)?;
        Ok(())
    }

    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error> {
        self.1.filter(self.0.filter(proposals)?)
    }
}

#[derive(Clone, Debug)]
pub struct MapErr<T, M> {
    filter: T,
    map: M,
}

impl<T, M, E> ProposalFilter for MapErr<T, M>
where
    T: ProposalFilter,
    M: Fn(T::Error) -> E,
    E: std::error::Error + Send + Sync + 'static,
{
    type Error = E;

    fn validate(&self, proposals: &ProposalBundle) -> Result<(), Self::Error> {
        self.filter.validate(proposals).map_err(&self.map)
    }

    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error> {
        self.filter.filter(proposals).map_err(&self.map)
    }
}

#[derive(Clone, Debug)]
pub struct PassThroughProposalFilter<E> {
    phantom: PhantomData<fn() -> E>,
}

impl<E> PassThroughProposalFilter<E> {
    pub fn new() -> Self {
        Self {
            phantom: PhantomData,
        }
    }
}

impl<E> Default for PassThroughProposalFilter<E> {
    fn default() -> Self {
        Self::new()
    }
}

impl<E> ProposalFilter for PassThroughProposalFilter<E>
where
    E: std::error::Error + Send + Sync + 'static,
{
    type Error = E;

    fn validate(&self, _: &ProposalBundle) -> Result<(), Self::Error> {
        Ok(())
    }

    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error> {
        Ok(proposals)
    }
}

#[derive(Debug, Error)]
pub enum ProposalFilterError {
    #[error(transparent)]
    KeyPackageValidationError(#[from] KeyPackageValidationError),
    #[error(transparent)]
    LeafNodeValidationError(#[from] LeafNodeValidationError),
    #[error(transparent)]
    RatchetTreeError(#[from] RatchetTreeError),
    #[error(transparent)]
    LeafNodeError(#[from] LeafNodeError),
    #[error("Commiter must not include any update proposals generated by the commiter")]
    InvalidCommitSelfUpdate,
    #[error("PSK type must be External in PreSharedKey proposal")]
    PskTypeMustBeExternalInPreSharedKeyProposal,
    #[error("Expected PSK nonce with length {expected} but found length {found}")]
    InvalidPskNonceLength { expected: usize, found: usize },
    #[error("Protocol version {proposed:?} in ReInit proposal is less than version {original:?} in original group")]
    InvalidProtocolVersionInReInit {
        proposed: ProtocolVersion,
        original: ProtocolVersion,
    },
    #[error("More than one proposal applying to leaf {0:?}")]
    MoreThanOneProposalForLeaf(LeafIndex),
    #[error("More than one GroupContextExtensions proposal")]
    MoreThanOneGroupContextExtensionsProposal,
    #[error("Invalid proposal of type {0:?} for proposer {1:?}")]
    InvalidProposalTypeForProposer(ProposalType, Sender),
    #[error("External commit must have exactly one ExternalInit proposal")]
    ExternalCommitMustHaveExactlyOneExternalInit,
    #[error("External sender cannot commit")]
    ExternalSenderCannotCommit,
    #[error("Missing update path in external commit")]
    MissingUpdatePathInExternalCommit,
    #[error("External commit contains removal of other identity")]
    ExternalCommitRemovesOtherIdentity,
    #[error("External commit contains more than one Remove proposal")]
    ExternalCommitWithMoreThanOneRemove,
    #[error("Duplicate PSK IDs")]
    DuplicatePskIds,
    #[error("ExternalInit must be committed by NewMember")]
    ExternalInitMustBeCommittedByNewMember,
    #[error("Invalid proposal type {0:?} in external commit")]
    InvalidProposalTypeInExternalCommit(ProposalType),
    #[error("Committer can not remove themselves")]
    CommitterSelfRemoval,
    #[error(transparent)]
    UserDefined(Box<dyn std::error::Error + Send + Sync>),
    #[error("Only members can commit proposals by reference")]
    OnlyMembersCanCommitProposalsByRef,
}
