use crate::{
    extension::{ExtensionError, ExtensionType},
    group::{proposal_filter::ProposalBundle, ProposalType, Sender},
    key_package::KeyPackageValidationError,
    signing_identity::SigningIdentityError,
    tree_kem::{
        leaf_node::LeafNodeError, leaf_node_validator::LeafNodeValidationError, node::LeafIndex,
        RatchetTreeError,
    },
    ProtocolVersion,
};
use std::marker::PhantomData;
use thiserror::Error;

pub trait ProposalFilter {
    type Error: std::error::Error + Send + Sync + 'static;

    /// This is called to validate a received commit. It should report any error making the commit
    /// invalid.
    fn validate(&self, proposals: &ProposalBundle) -> Result<(), Self::Error>;

    /// This is called when preparing a commit. By-reference proposals causing the commit to be
    /// invalid should be filtered out. If a by-value proposal causes the commit to be invalid,
    /// an error should be returned.
    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error>;

    fn boxed(self) -> BoxedProposalFilter<Self::Error>
    where
        Self: Send + Sync + Sized + 'static,
    {
        Box::new(self)
    }
}

pub type BoxedProposalFilter<E> = Box<dyn ProposalFilter<Error = E> + Send + Sync>;

impl<T: ProposalFilter + ?Sized> ProposalFilter for Box<T> {
    type Error = T::Error;

    fn validate(&self, proposals: &ProposalBundle) -> Result<(), Self::Error> {
        (**self).validate(proposals)
    }

    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error> {
        (**self).filter(proposals)
    }
}

#[derive(Clone, Debug)]
pub struct PassThroughProposalFilter<E> {
    phantom: PhantomData<fn() -> E>,
}

impl<E> PassThroughProposalFilter<E> {
    pub fn new() -> Self {
        Self {
            phantom: PhantomData,
        }
    }
}

impl<E> Default for PassThroughProposalFilter<E> {
    fn default() -> Self {
        Self::new()
    }
}

impl<E> ProposalFilter for PassThroughProposalFilter<E>
where
    E: std::error::Error + Send + Sync + 'static,
{
    type Error = E;

    fn validate(&self, _: &ProposalBundle) -> Result<(), Self::Error> {
        Ok(())
    }

    fn filter(&self, proposals: ProposalBundle) -> Result<ProposalBundle, Self::Error> {
        Ok(proposals)
    }
}

#[derive(Debug, Error)]
pub enum ProposalFilterError {
    #[error(transparent)]
    KeyPackageValidationError(#[from] KeyPackageValidationError),
    #[error(transparent)]
    LeafNodeValidationError(#[from] LeafNodeValidationError),
    #[error(transparent)]
    RatchetTreeError(#[from] RatchetTreeError),
    #[error(transparent)]
    ExtensionError(#[from] ExtensionError),
    #[error(transparent)]
    LeafNodeError(#[from] LeafNodeError),
    #[error(transparent)]
    SigningIdentityError(#[from] SigningIdentityError),
    #[error("Commiter must not include any update proposals generated by the commiter")]
    InvalidCommitSelfUpdate,
    #[error("A PreSharedKey proposal must have a PSK of type External or type Resumption and usage Application")]
    InvalidTypeOrUsageInPreSharedKeyProposal,
    #[error("Expected PSK nonce with length {expected} but found length {found}")]
    InvalidPskNonceLength { expected: usize, found: usize },
    #[error("Protocol version {proposed:?} in ReInit proposal is less than version {original:?} in original group")]
    InvalidProtocolVersionInReInit {
        proposed: ProtocolVersion,
        original: ProtocolVersion,
    },
    #[error("More than one proposal applying to leaf {0:?}")]
    MoreThanOneProposalForLeaf(LeafIndex),
    #[error("More than one GroupContextExtensions proposal")]
    MoreThanOneGroupContextExtensionsProposal,
    #[error("Invalid proposal of type {0:?} for proposer {1:?}")]
    InvalidProposalTypeForProposer(ProposalType, Sender),
    #[error("External commit must have exactly one ExternalInit proposal")]
    ExternalCommitMustHaveExactlyOneExternalInit,
    #[error("External commit must have a new leaf")]
    ExternalCommitMustHaveNewLeaf,
    #[error("External sender cannot commit")]
    ExternalSenderCannotCommit,
    #[error("Missing update path in external commit")]
    MissingUpdatePathInExternalCommit,
    #[error("External commit contains removal of other identity")]
    ExternalCommitRemovesOtherIdentity,
    #[error("External commit contains more than one Remove proposal")]
    ExternalCommitWithMoreThanOneRemove,
    #[error("Duplicate PSK IDs")]
    DuplicatePskIds,
    #[error("ExternalInit must be committed by NewMember")]
    ExternalInitMustBeCommittedByNewMember,
    #[error("Invalid proposal type {0:?} in external commit")]
    InvalidProposalTypeInExternalCommit(ProposalType),
    #[error("Committer can not remove themselves")]
    CommitterSelfRemoval,
    #[error(transparent)]
    UserDefined(Box<dyn std::error::Error + Send + Sync>),
    #[error("Only members can commit proposals by reference")]
    OnlyMembersCanCommitProposalsByRef,
    #[error("Other proposal with ReInit")]
    OtherProposalWithReInit,
    #[error("Removing blank node at index {0:?}")]
    RemovingBlankNode(LeafIndex),
    #[error("Unsupported group extension {0}")]
    UnsupportedGroupExtension(ExtensionType),
}

impl ProposalFilterError {
    pub fn user_defined<E>(e: E) -> Self
    where
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Self::UserDefined(e.into())
    }
}
